{"ast":null,"code":"import { ethers } from 'ethers';\nimport Web3 from 'web3';\nconst web3 = new Web3(Web3.givenProvider);\n\nconst poolContract = require('../abi/pool.json');\n\nconst poolContractMeta = require('../abi/artifacts/contracts/Pool/Pool.sol/Pool.json');\n\nconst ecr20abi = require('../abi/erc20.json');\n\nconst _interface = new ethers.utils.Interface(poolContractMeta.abi);\n\nconst initializeFragement = _interface.getFunction('depositCollateral');\n\nconst onLendingSuccess = (hash, callback) => {\n  const onCreateInterval = setInterval(async () => {\n    web3.eth.getTransactionReceipt(hash).then(txReceipt => {\n      if ((txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.status) === true) {\n        clearInterval(onCreateInterval);\n        console.log('true TXRECEIPT', txReceipt);\n        callback({\n          success: true\n        });\n      } else if ((txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.status) === false) {\n        console.log('false TXRECEIPT', txReceipt);\n      }\n    });\n  }, 5000);\n};\n\nexport async function addCollateral(amount, poolAddress, tokenAddress, callback) {\n  let newAmount = ethers.utils.parseUnits(amount.toString()).toString();\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  const signer = provider.getSigner();\n  let lender = await signer.getAddress();\n\n  const result = _interface.encodeFunctionData(initializeFragement, [newAmount, false]);\n\n  var contract = new web3.eth.Contract(poolContract, poolAddress);\n  var erc20contract = new web3.eth.Contract(ecr20abi, tokenAddress);\n\n  try {\n    await erc20contract.methods.approve(poolAddress, newAmount).send({\n      from: lender\n    }, async (error, receipt) => {\n      if (error) {\n        callback({\n          error: true,\n          message: error.message\n        });\n        return;\n      }\n\n      const interval = setInterval(async () => {\n        web3.eth.getTransactionReceipt(receipt).then(async txReceipt => {\n          if ((txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.status) === true) {\n            clearInterval(interval);\n            const isAllowed = await erc20contract.methods.allowance(lender, poolAddress).call();\n            await contract.methods.depositCollateral(newAmount, false).send({\n              from: lender\n            }, function async(err, res) {\n              if (err) {\n                console.log('LEND ERROR', err);\n                callback({\n                  error: true,\n                  message: err.message\n                });\n                return;\n              }\n\n              if (res) {\n                console.log('LEND HASH', res);\n                onLendingSuccess(res, callback);\n              }\n            });\n          } else if ((txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.status) === false) {\n            console.log('approve false TXRECEIPT', txReceipt);\n          }\n        });\n      }, 5000);\n    });\n  } catch (error) {\n    if (error.message.includes('User denied transaction')) {\n      callback({\n        error: true,\n        message: error.message\n      });\n    } else {\n      callback({\n        error: true,\n        message: 'Invalid values entered.'\n      });\n    }\n  }\n}","map":{"version":3,"sources":["/Users/ritikdutta/Desktop/SUBLIME/sublime-frontend/src/contractTranscations/addCollateral.js"],"names":["ethers","Web3","web3","givenProvider","poolContract","require","poolContractMeta","ecr20abi","_interface","utils","Interface","abi","initializeFragement","getFunction","onLendingSuccess","hash","callback","onCreateInterval","setInterval","eth","getTransactionReceipt","then","txReceipt","status","clearInterval","console","log","success","addCollateral","amount","poolAddress","tokenAddress","newAmount","parseUnits","toString","provider","providers","Web3Provider","window","ethereum","signer","getSigner","lender","getAddress","result","encodeFunctionData","contract","Contract","erc20contract","methods","approve","send","from","error","receipt","message","interval","isAllowed","allowance","call","depositCollateral","async","err","res","includes"],"mappings":"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","sourcesContent":["import { ethers } from 'ethers';\nimport Web3 from 'web3';\nconst web3 = new Web3(Web3.givenProvider);\n\nconst poolContract = require('../abi/pool.json');\nconst poolContractMeta = require('../abi/artifacts/contracts/Pool/Pool.sol/Pool.json');\nconst ecr20abi = require('../abi/erc20.json');\n\nconst _interface = new ethers.utils.Interface(poolContractMeta.abi);\nconst initializeFragement = _interface.getFunction('depositCollateral');\n\nconst onLendingSuccess = (hash, callback) => {\n  const onCreateInterval = setInterval(async () => {\n    web3.eth.getTransactionReceipt(hash).then((txReceipt) => {\n      if (txReceipt?.status === true) {\n        clearInterval(onCreateInterval);\n\n        console.log('true TXRECEIPT', txReceipt);\n        callback({ success: true });\n      } else if (txReceipt?.status === false) {\n        console.log('false TXRECEIPT', txReceipt);\n      }\n    });\n  }, 5000);\n};\n\nexport async function addCollateral(amount, poolAddress, tokenAddress, callback) {\n  let newAmount = ethers.utils.parseUnits(amount.toString()).toString();\n\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  const signer = provider.getSigner();\n  let lender = await signer.getAddress();\n\n  const result = _interface.encodeFunctionData(initializeFragement, [newAmount, false]);\n\n  var contract = new web3.eth.Contract(poolContract, poolAddress);\n  var erc20contract = new web3.eth.Contract(ecr20abi, tokenAddress);\n\n  try {\n    await erc20contract.methods.approve(poolAddress, newAmount).send({ from: lender }, async (error, receipt) => {\n      if (error) {\n        callback({ error: true, message: error.message });\n        return;\n      }\n\n      const interval = setInterval(async () => {\n        web3.eth.getTransactionReceipt(receipt).then(async (txReceipt) => {\n          if (txReceipt?.status === true) {\n            clearInterval(interval);\n\n            const isAllowed = await erc20contract.methods.allowance(lender, poolAddress).call();\n            await contract.methods.depositCollateral(newAmount, false).send({ from: lender }, function async(err, res) {\n              if (err) {\n                console.log('LEND ERROR', err);\n                callback({ error: true, message: err.message });\n                return;\n              }\n              if (res) {\n                console.log('LEND HASH', res);\n                onLendingSuccess(res, callback);\n              }\n            });\n          } else if (txReceipt?.status === false) {\n            console.log('approve false TXRECEIPT', txReceipt);\n          }\n        });\n      }, 5000);\n    });\n  } catch (error) {\n    if (error.message.includes('User denied transaction')) {\n      callback({ error: true, message: error.message });\n    } else {\n      callback({ error: true, message: 'Invalid values entered.' });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}