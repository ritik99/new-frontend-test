{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recoverTypedSignature_v4 = exports.recoverTypedSignature = exports.signTypedData_v4 = exports.signTypedData = exports.recoverTypedMessage = exports.signTypedMessage = exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = exports.recoverTypedSignatureLegacy = exports.signTypedDataLegacy = exports.typedSignatureHash = exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = exports.normalize = exports.concatSig = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = void 0;\n\nconst ethUtil = __importStar(require(\"ethereumjs-util\"));\n\nconst ethAbi = __importStar(require(\"ethereumjs-abi\"));\n\nconst nacl = __importStar(require(\"tweetnacl\"));\n\nconst naclUtil = __importStar(require(\"tweetnacl-util\"));\n\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string'\n            },\n            type: {\n              type: 'string'\n            }\n          },\n          required: ['name', 'type']\n        }\n      }\n    },\n    primaryType: {\n      type: 'string'\n    },\n    domain: {\n      type: 'object'\n    },\n    message: {\n      type: 'object'\n    }\n  },\n  required: ['types', 'primaryType', 'domain', 'message']\n};\nexports.TYPED_MESSAGE_SCHEMA = TYPED_MESSAGE_SCHEMA;\n/**\n * A collection of utility functions used for signing typed data\n */\n\nconst TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {Buffer} - Encoded representation of an object\n   */\n  encodeData(primaryType, data, types, useV4 = true) {\n    const encodedTypes = ['bytes32'];\n    const encodedValues = [this.hashType(primaryType, types)];\n\n    if (useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value == null // eslint-disable-line no-eq-null\n          ? '0x0000000000000000000000000000000000000000000000000000000000000000' : ethUtil.keccak(this.encodeData(type, value, types, useV4))];\n        }\n\n        if (value === undefined) {\n          throw new Error(`missing value for field ${name} of type ${type}`);\n        }\n\n        if (type === 'bytes') {\n          return ['bytes32', ethUtil.keccak(value)];\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8');\n          }\n\n          return ['bytes32', ethUtil.keccak(value)];\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['));\n          const typeValuePairs = value.map(item => encodeField(name, parsedType, item));\n          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))];\n        }\n\n        return [type, value];\n      };\n\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name]);\n        encodedTypes.push(type);\n        encodedValues.push(value);\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name];\n\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32');\n            value = ethUtil.keccak(value);\n            encodedValues.push(value);\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32'); // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8');\n            }\n\n            value = ethUtil.keccak(value);\n            encodedValues.push(value);\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32');\n            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4));\n            encodedValues.push(value);\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays are unimplemented in encodeData; use V4 extension');\n          } else {\n            encodedTypes.push(field.type);\n            encodedValues.push(value);\n          }\n        }\n      }\n    }\n\n    return ethAbi.rawEncode(encodedTypes, encodedValues);\n  },\n\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType(primaryType, types) {\n    let result = '';\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType);\n    deps = [primaryType].concat(deps.sort());\n\n    for (const type of deps) {\n      const children = types[type];\n\n      if (!children) {\n        throw new Error(`No type definition specified: ${type}`);\n      }\n\n      result += `${type}(${types[type].map(({\n        name,\n        type: t\n      }) => `${t} ${name}`).join(',')})`;\n    }\n\n    return result;\n  },\n\n  /**\n   * Finds all types within a type definition object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies(primaryType, types, results = []) {\n    [primaryType] = primaryType.match(/^\\w*/u);\n\n    if (results.includes(primaryType) || types[primaryType] === undefined) {\n      return results;\n    }\n\n    results.push(primaryType);\n\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep);\n      }\n    }\n\n    return results;\n  },\n\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {Buffer} - Hash of an object\n   */\n  hashStruct(primaryType, data, types, useV4 = true) {\n    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4));\n  },\n\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {Buffer} - Hash of an object\n   */\n  hashType(primaryType, types) {\n    return ethUtil.keccak(this.encodeType(primaryType, types));\n  },\n\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData(data) {\n    const sanitizedData = {};\n\n    for (const key in TYPED_MESSAGE_SCHEMA.properties) {\n      if (data[key]) {\n        sanitizedData[key] = data[key];\n      }\n    }\n\n    if ('types' in sanitizedData) {\n      sanitizedData.types = Object.assign({\n        EIP712Domain: []\n      }, sanitizedData.types);\n    }\n\n    return sanitizedData;\n  },\n\n  /**\n   * Signs a typed message as per EIP-712 and returns its keccak hash\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {Buffer} - keccak hash of the resulting signed message\n   */\n  sign(typedData, useV4 = true) {\n    const sanitizedData = this.sanitizeData(typedData);\n    const parts = [Buffer.from('1901', 'hex')];\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));\n\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));\n    }\n\n    return ethUtil.keccak(Buffer.concat(parts));\n  }\n\n};\nexports.TypedDataUtils = TypedDataUtils;\n\nfunction concatSig(v, r, s) {\n  const rSig = ethUtil.fromSigned(r);\n  const sSig = ethUtil.fromSigned(s);\n  const vSig = ethUtil.bufferToInt(v);\n  const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64);\n  const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64);\n  const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));\n  return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex');\n}\n\nexports.concatSig = concatSig;\n\nfunction normalize(input) {\n  if (!input) {\n    return undefined;\n  }\n\n  if (typeof input === 'number') {\n    const buffer = ethUtil.toBuffer(input);\n    input = ethUtil.bufferToHex(buffer);\n  }\n\n  if (typeof input !== 'string') {\n    let msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n    msg += ` received ${typeof input}: ${input}`;\n    throw new Error(msg);\n  }\n\n  return ethUtil.addHexPrefix(input.toLowerCase());\n}\n\nexports.normalize = normalize;\n\nfunction personalSign(privateKey, msgParams) {\n  const message = ethUtil.toBuffer(msgParams.data);\n  const msgHash = ethUtil.hashPersonalMessage(message);\n  const sig = ethUtil.ecsign(msgHash, privateKey);\n  const serialized = ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));\n  return serialized;\n}\n\nexports.personalSign = personalSign;\n\nfunction recoverPersonalSignature(msgParams) {\n  const publicKey = getPublicKeyFor(msgParams);\n  const sender = ethUtil.publicToAddress(publicKey);\n  const senderHex = ethUtil.bufferToHex(sender);\n  return senderHex;\n}\n\nexports.recoverPersonalSignature = recoverPersonalSignature;\n\nfunction extractPublicKey(msgParams) {\n  const publicKey = getPublicKeyFor(msgParams);\n  return `0x${publicKey.toString('hex')}`;\n}\n\nexports.extractPublicKey = extractPublicKey;\n\nfunction externalTypedSignatureHash(typedData) {\n  const hashBuffer = typedSignatureHash(typedData);\n  return ethUtil.bufferToHex(hashBuffer);\n}\n\nexports.typedSignatureHash = externalTypedSignatureHash;\n\nfunction signTypedDataLegacy(privateKey, msgParams) {\n  const msgHash = typedSignatureHash(msgParams.data);\n  const sig = ethUtil.ecsign(msgHash, privateKey);\n  return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));\n}\n\nexports.signTypedDataLegacy = signTypedDataLegacy;\n\nfunction recoverTypedSignatureLegacy(msgParams) {\n  const msgHash = typedSignatureHash(msgParams.data);\n  const publicKey = recoverPublicKey(msgHash, msgParams.sig);\n  const sender = ethUtil.publicToAddress(publicKey);\n  return ethUtil.bufferToHex(sender);\n}\n\nexports.recoverTypedSignatureLegacy = recoverTypedSignatureLegacy;\n\nfunction encrypt(receiverPublicKey, msgParams, version) {\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        if (typeof msgParams.data !== 'string') {\n          throw new Error('Cannot detect secret message, message params should be of the form {data: \"secret message\"} ');\n        } // generate ephemeral keypair\n\n\n        const ephemeralKeyPair = nacl.box.keyPair(); // assemble encryption parameters - from string to UInt8\n\n        let pubKeyUInt8Array;\n\n        try {\n          pubKeyUInt8Array = naclUtil.decodeBase64(receiverPublicKey);\n        } catch (err) {\n          throw new Error('Bad public key');\n        }\n\n        const msgParamsUInt8Array = naclUtil.decodeUTF8(msgParams.data);\n        const nonce = nacl.randomBytes(nacl.box.nonceLength); // encrypt\n\n        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey); // handle encrypted data\n\n        const output = {\n          version: 'x25519-xsalsa20-poly1305',\n          nonce: naclUtil.encodeBase64(nonce),\n          ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n          ciphertext: naclUtil.encodeBase64(encryptedMessage)\n        }; // return encrypted msg data\n\n        return output;\n      }\n\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\n\nexports.encrypt = encrypt;\n\nfunction encryptSafely(receiverPublicKey, msgParams, version) {\n  const DEFAULT_PADDING_LENGTH = 2 ** 11;\n  const NACL_EXTRA_BYTES = 16;\n  const {\n    data\n  } = msgParams;\n\n  if (!data) {\n    throw new Error('Cannot encrypt empty msg.data');\n  }\n\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n  } // add padding\n\n\n  const dataWithPadding = {\n    data,\n    padding: ''\n  }; // calculate padding\n\n  const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n  const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  let padLength = 0; // Only pad if necessary\n\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n\n  dataWithPadding.padding = '0'.repeat(padLength);\n  const paddedMsgParams = {\n    data: JSON.stringify(dataWithPadding)\n  };\n  return encrypt(receiverPublicKey, paddedMsgParams, version);\n}\n\nexports.encryptSafely = encryptSafely;\n\nfunction decrypt(encryptedData, receiverPrivateKey) {\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        // string to buffer to UInt8Array\n        const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey);\n        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey; // assemble decryption parameters\n\n        const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n        const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n        const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey); // decrypt\n\n        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey); // return decrypted msg data\n\n        let output;\n\n        try {\n          output = naclUtil.encodeUTF8(decryptedMessage);\n        } catch (err) {\n          throw new Error('Decryption failed.');\n        }\n\n        if (output) {\n          return output;\n        }\n\n        throw new Error('Decryption failed.');\n      }\n\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\n\nexports.decrypt = decrypt;\n\nfunction decryptSafely(encryptedData, receiverPrivateKey) {\n  const dataWithPadding = JSON.parse(decrypt(encryptedData, receiverPrivateKey));\n  return dataWithPadding.data;\n}\n\nexports.decryptSafely = decryptSafely;\n\nfunction getEncryptionPublicKey(privateKey) {\n  const privateKeyUint8Array = nacl_decodeHex(privateKey);\n  const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\n\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n/**\n * A generic entry point for all typed data methods to be passed, includes a version parameter.\n */\n\nfunction signTypedMessage(privateKey, msgParams, version = 'V4') {\n  switch (version) {\n    case 'V1':\n      return signTypedDataLegacy(privateKey, msgParams);\n\n    case 'V3':\n      return signTypedData(privateKey, msgParams);\n\n    case 'V4':\n    default:\n      return signTypedData_v4(privateKey, msgParams);\n  }\n}\n\nexports.signTypedMessage = signTypedMessage;\n\nfunction recoverTypedMessage(msgParams, version = 'V4') {\n  switch (version) {\n    case 'V1':\n      return recoverTypedSignatureLegacy(msgParams);\n\n    case 'V3':\n      return recoverTypedSignature(msgParams);\n\n    case 'V4':\n    default:\n      return recoverTypedSignature_v4(msgParams);\n  }\n}\n\nexports.recoverTypedMessage = recoverTypedMessage;\n\nfunction signTypedData(privateKey, msgParams) {\n  const message = TypedDataUtils.sign(msgParams.data, false);\n  const sig = ethUtil.ecsign(message, privateKey);\n  return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));\n}\n\nexports.signTypedData = signTypedData;\n\nfunction signTypedData_v4(privateKey, msgParams) {\n  const message = TypedDataUtils.sign(msgParams.data);\n  const sig = ethUtil.ecsign(message, privateKey);\n  return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));\n}\n\nexports.signTypedData_v4 = signTypedData_v4;\n\nfunction recoverTypedSignature(msgParams) {\n  const message = TypedDataUtils.sign(msgParams.data, false);\n  const publicKey = recoverPublicKey(message, msgParams.sig);\n  const sender = ethUtil.publicToAddress(publicKey);\n  return ethUtil.bufferToHex(sender);\n}\n\nexports.recoverTypedSignature = recoverTypedSignature;\n\nfunction recoverTypedSignature_v4(msgParams) {\n  const message = TypedDataUtils.sign(msgParams.data);\n  const publicKey = recoverPublicKey(message, msgParams.sig);\n  const sender = ethUtil.publicToAddress(publicKey);\n  return ethUtil.bufferToHex(sender);\n}\n\nexports.recoverTypedSignature_v4 = recoverTypedSignature_v4;\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\n\nfunction typedSignatureHash(typedData) {\n  const error = new Error('Expect argument to be non-empty array');\n\n  if (typeof typedData !== 'object' || !('length' in typedData) || !typedData.length) {\n    throw error;\n  }\n\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value;\n  });\n  const types = typedData.map(function (e) {\n    return e.type;\n  });\n  const schema = typedData.map(function (e) {\n    if (!e.name) {\n      throw error;\n    }\n\n    return `${e.type} ${e.name}`;\n  });\n  return ethAbi.soliditySHA3(['bytes32', 'bytes32'], [ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema), ethAbi.soliditySHA3(types, data)]);\n}\n\nfunction recoverPublicKey(hash, sig) {\n  const signature = ethUtil.toBuffer(sig);\n  const sigParams = ethUtil.fromRpcSig(signature);\n  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);\n}\n\nfunction getPublicKeyFor(msgParams) {\n  const message = ethUtil.toBuffer(msgParams.data);\n  const msgHash = ethUtil.hashPersonalMessage(message);\n  return recoverPublicKey(msgHash, msgParams.sig);\n}\n\nfunction padWithZeroes(number, length) {\n  let myString = `${number}`;\n\n  while (myString.length < length) {\n    myString = `0${myString}`;\n  }\n\n  return myString;\n} // converts hex strings to the Uint8Array format used by nacl\n\n\nfunction nacl_decodeHex(msgHex) {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.recoverTypedSignature_v4 = exports.recoverTypedSignature = exports.signTypedData_v4 = exports.signTypedData = exports.recoverTypedMessage = exports.signTypedMessage = exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = exports.recoverTypedSignatureLegacy = exports.signTypedDataLegacy = exports.typedSignatureHash = exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = exports.normalize = exports.concatSig = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = void 0;\nconst ethUtil = __importStar(require(\"ethereumjs-util\"));\nconst ethAbi = __importStar(require(\"ethereumjs-abi\"));\nconst nacl = __importStar(require(\"tweetnacl\"));\nconst naclUtil = __importStar(require(\"tweetnacl-util\"));\nconst TYPED_MESSAGE_SCHEMA = {\n    type: 'object',\n    properties: {\n        types: {\n            type: 'object',\n            additionalProperties: {\n                type: 'array',\n                items: {\n                    type: 'object',\n                    properties: {\n                        name: { type: 'string' },\n                        type: { type: 'string' },\n                    },\n                    required: ['name', 'type'],\n                },\n            },\n        },\n        primaryType: { type: 'string' },\n        domain: { type: 'object' },\n        message: { type: 'object' },\n    },\n    required: ['types', 'primaryType', 'domain', 'message'],\n};\nexports.TYPED_MESSAGE_SCHEMA = TYPED_MESSAGE_SCHEMA;\n/**\n * A collection of utility functions used for signing typed data\n */\nconst TypedDataUtils = {\n    /**\n     * Encodes an object by encoding and concatenating each of its members\n     *\n     * @param {string} primaryType - Root type\n     * @param {Object} data - Object to encode\n     * @param {Object} types - Type definitions\n     * @returns {Buffer} - Encoded representation of an object\n     */\n    encodeData(primaryType, data, types, useV4 = true) {\n        const encodedTypes = ['bytes32'];\n        const encodedValues = [this.hashType(primaryType, types)];\n        if (useV4) {\n            const encodeField = (name, type, value) => {\n                if (types[type] !== undefined) {\n                    return [\n                        'bytes32',\n                        value == null // eslint-disable-line no-eq-null\n                            ? '0x0000000000000000000000000000000000000000000000000000000000000000'\n                            : ethUtil.keccak(this.encodeData(type, value, types, useV4)),\n                    ];\n                }\n                if (value === undefined) {\n                    throw new Error(`missing value for field ${name} of type ${type}`);\n                }\n                if (type === 'bytes') {\n                    return ['bytes32', ethUtil.keccak(value)];\n                }\n                if (type === 'string') {\n                    // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n                    if (typeof value === 'string') {\n                        value = Buffer.from(value, 'utf8');\n                    }\n                    return ['bytes32', ethUtil.keccak(value)];\n                }\n                if (type.lastIndexOf(']') === type.length - 1) {\n                    const parsedType = type.slice(0, type.lastIndexOf('['));\n                    const typeValuePairs = value.map((item) => encodeField(name, parsedType, item));\n                    return [\n                        'bytes32',\n                        ethUtil.keccak(ethAbi.rawEncode(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),\n                    ];\n                }\n                return [type, value];\n            };\n            for (const field of types[primaryType]) {\n                const [type, value] = encodeField(field.name, field.type, data[field.name]);\n                encodedTypes.push(type);\n                encodedValues.push(value);\n            }\n        }\n        else {\n            for (const field of types[primaryType]) {\n                let value = data[field.name];\n                if (value !== undefined) {\n                    if (field.type === 'bytes') {\n                        encodedTypes.push('bytes32');\n                        value = ethUtil.keccak(value);\n                        encodedValues.push(value);\n                    }\n                    else if (field.type === 'string') {\n                        encodedTypes.push('bytes32');\n                        // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n                        if (typeof value === 'string') {\n                            value = Buffer.from(value, 'utf8');\n                        }\n                        value = ethUtil.keccak(value);\n                        encodedValues.push(value);\n                    }\n                    else if (types[field.type] !== undefined) {\n                        encodedTypes.push('bytes32');\n                        value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4));\n                        encodedValues.push(value);\n                    }\n                    else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n                        throw new Error('Arrays are unimplemented in encodeData; use V4 extension');\n                    }\n                    else {\n                        encodedTypes.push(field.type);\n                        encodedValues.push(value);\n                    }\n                }\n            }\n        }\n        return ethAbi.rawEncode(encodedTypes, encodedValues);\n    },\n    /**\n     * Encodes the type of an object by encoding a comma delimited list of its members\n     *\n     * @param {string} primaryType - Root type to encode\n     * @param {Object} types - Type definitions\n     * @returns {string} - Encoded representation of the type of an object\n     */\n    encodeType(primaryType, types) {\n        let result = '';\n        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);\n        deps = [primaryType].concat(deps.sort());\n        for (const type of deps) {\n            const children = types[type];\n            if (!children) {\n                throw new Error(`No type definition specified: ${type}`);\n            }\n            result += `${type}(${types[type]\n                .map(({ name, type: t }) => `${t} ${name}`)\n                .join(',')})`;\n        }\n        return result;\n    },\n    /**\n     * Finds all types within a type definition object\n     *\n     * @param {string} primaryType - Root type\n     * @param {Object} types - Type definitions\n     * @param {Array} results - current set of accumulated types\n     * @returns {Array} - Set of all types found in the type definition\n     */\n    findTypeDependencies(primaryType, types, results = []) {\n        [primaryType] = primaryType.match(/^\\w*/u);\n        if (results.includes(primaryType) || types[primaryType] === undefined) {\n            return results;\n        }\n        results.push(primaryType);\n        for (const field of types[primaryType]) {\n            for (const dep of this.findTypeDependencies(field.type, types, results)) {\n                !results.includes(dep) && results.push(dep);\n            }\n        }\n        return results;\n    },\n    /**\n     * Hashes an object\n     *\n     * @param {string} primaryType - Root type\n     * @param {Object} data - Object to hash\n     * @param {Object} types - Type definitions\n     * @returns {Buffer} - Hash of an object\n     */\n    hashStruct(primaryType, data, types, useV4 = true) {\n        return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4));\n    },\n    /**\n     * Hashes the type of an object\n     *\n     * @param {string} primaryType - Root type to hash\n     * @param {Object} types - Type definitions\n     * @returns {Buffer} - Hash of an object\n     */\n    hashType(primaryType, types) {\n        return ethUtil.keccak(this.encodeType(primaryType, types));\n    },\n    /**\n     * Removes properties from a message object that are not defined per EIP-712\n     *\n     * @param {Object} data - typed message object\n     * @returns {Object} - typed message object with only allowed fields\n     */\n    sanitizeData(data) {\n        const sanitizedData = {};\n        for (const key in TYPED_MESSAGE_SCHEMA.properties) {\n            if (data[key]) {\n                sanitizedData[key] = data[key];\n            }\n        }\n        if ('types' in sanitizedData) {\n            sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);\n        }\n        return sanitizedData;\n    },\n    /**\n     * Signs a typed message as per EIP-712 and returns its keccak hash\n     *\n     * @param {Object} typedData - Types message data to sign\n     * @returns {Buffer} - keccak hash of the resulting signed message\n     */\n    sign(typedData, useV4 = true) {\n        const sanitizedData = this.sanitizeData(typedData);\n        const parts = [Buffer.from('1901', 'hex')];\n        parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));\n        if (sanitizedData.primaryType !== 'EIP712Domain') {\n            parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));\n        }\n        return ethUtil.keccak(Buffer.concat(parts));\n    },\n};\nexports.TypedDataUtils = TypedDataUtils;\nfunction concatSig(v, r, s) {\n    const rSig = ethUtil.fromSigned(r);\n    const sSig = ethUtil.fromSigned(s);\n    const vSig = ethUtil.bufferToInt(v);\n    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64);\n    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64);\n    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));\n    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex');\n}\nexports.concatSig = concatSig;\nfunction normalize(input) {\n    if (!input) {\n        return undefined;\n    }\n    if (typeof input === 'number') {\n        const buffer = ethUtil.toBuffer(input);\n        input = ethUtil.bufferToHex(buffer);\n    }\n    if (typeof input !== 'string') {\n        let msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n        msg += ` received ${typeof input}: ${input}`;\n        throw new Error(msg);\n    }\n    return ethUtil.addHexPrefix(input.toLowerCase());\n}\nexports.normalize = normalize;\nfunction personalSign(privateKey, msgParams) {\n    const message = ethUtil.toBuffer(msgParams.data);\n    const msgHash = ethUtil.hashPersonalMessage(message);\n    const sig = ethUtil.ecsign(msgHash, privateKey);\n    const serialized = ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));\n    return serialized;\n}\nexports.personalSign = personalSign;\nfunction recoverPersonalSignature(msgParams) {\n    const publicKey = getPublicKeyFor(msgParams);\n    const sender = ethUtil.publicToAddress(publicKey);\n    const senderHex = ethUtil.bufferToHex(sender);\n    return senderHex;\n}\nexports.recoverPersonalSignature = recoverPersonalSignature;\nfunction extractPublicKey(msgParams) {\n    const publicKey = getPublicKeyFor(msgParams);\n    return `0x${publicKey.toString('hex')}`;\n}\nexports.extractPublicKey = extractPublicKey;\nfunction externalTypedSignatureHash(typedData) {\n    const hashBuffer = typedSignatureHash(typedData);\n    return ethUtil.bufferToHex(hashBuffer);\n}\nexports.typedSignatureHash = externalTypedSignatureHash;\nfunction signTypedDataLegacy(privateKey, msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data);\n    const sig = ethUtil.ecsign(msgHash, privateKey);\n    return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));\n}\nexports.signTypedDataLegacy = signTypedDataLegacy;\nfunction recoverTypedSignatureLegacy(msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data);\n    const publicKey = recoverPublicKey(msgHash, msgParams.sig);\n    const sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n}\nexports.recoverTypedSignatureLegacy = recoverTypedSignatureLegacy;\nfunction encrypt(receiverPublicKey, msgParams, version) {\n    switch (version) {\n        case 'x25519-xsalsa20-poly1305': {\n            if (typeof msgParams.data !== 'string') {\n                throw new Error('Cannot detect secret message, message params should be of the form {data: \"secret message\"} ');\n            }\n            // generate ephemeral keypair\n            const ephemeralKeyPair = nacl.box.keyPair();\n            // assemble encryption parameters - from string to UInt8\n            let pubKeyUInt8Array;\n            try {\n                pubKeyUInt8Array = naclUtil.decodeBase64(receiverPublicKey);\n            }\n            catch (err) {\n                throw new Error('Bad public key');\n            }\n            const msgParamsUInt8Array = naclUtil.decodeUTF8(msgParams.data);\n            const nonce = nacl.randomBytes(nacl.box.nonceLength);\n            // encrypt\n            const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);\n            // handle encrypted data\n            const output = {\n                version: 'x25519-xsalsa20-poly1305',\n                nonce: naclUtil.encodeBase64(nonce),\n                ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n                ciphertext: naclUtil.encodeBase64(encryptedMessage),\n            };\n            // return encrypted msg data\n            return output;\n        }\n        default:\n            throw new Error('Encryption type/version not supported');\n    }\n}\nexports.encrypt = encrypt;\nfunction encryptSafely(receiverPublicKey, msgParams, version) {\n    const DEFAULT_PADDING_LENGTH = 2 ** 11;\n    const NACL_EXTRA_BYTES = 16;\n    const { data } = msgParams;\n    if (!data) {\n        throw new Error('Cannot encrypt empty msg.data');\n    }\n    if (typeof data === 'object' && 'toJSON' in data) {\n        // remove toJSON attack vector\n        // TODO, check all possible children\n        throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n    }\n    // add padding\n    const dataWithPadding = {\n        data,\n        padding: '',\n    };\n    // calculate padding\n    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n    const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n    let padLength = 0;\n    // Only pad if necessary\n    if (modVal > 0) {\n        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n    }\n    dataWithPadding.padding = '0'.repeat(padLength);\n    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) };\n    return encrypt(receiverPublicKey, paddedMsgParams, version);\n}\nexports.encryptSafely = encryptSafely;\nfunction decrypt(encryptedData, receiverPrivateKey) {\n    switch (encryptedData.version) {\n        case 'x25519-xsalsa20-poly1305': {\n            // string to buffer to UInt8Array\n            const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey);\n            const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;\n            // assemble decryption parameters\n            const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n            const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n            const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);\n            // decrypt\n            const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);\n            // return decrypted msg data\n            let output;\n            try {\n                output = naclUtil.encodeUTF8(decryptedMessage);\n            }\n            catch (err) {\n                throw new Error('Decryption failed.');\n            }\n            if (output) {\n                return output;\n            }\n            throw new Error('Decryption failed.');\n        }\n        default:\n            throw new Error('Encryption type/version not supported.');\n    }\n}\nexports.decrypt = decrypt;\nfunction decryptSafely(encryptedData, receiverPrivateKey) {\n    const dataWithPadding = JSON.parse(decrypt(encryptedData, receiverPrivateKey));\n    return dataWithPadding.data;\n}\nexports.decryptSafely = decryptSafely;\nfunction getEncryptionPublicKey(privateKey) {\n    const privateKeyUint8Array = nacl_decodeHex(privateKey);\n    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n    return naclUtil.encodeBase64(encryptionPublicKey);\n}\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n/**\n * A generic entry point for all typed data methods to be passed, includes a version parameter.\n */\nfunction signTypedMessage(privateKey, msgParams, version = 'V4') {\n    switch (version) {\n        case 'V1':\n            return signTypedDataLegacy(privateKey, msgParams);\n        case 'V3':\n            return signTypedData(privateKey, msgParams);\n        case 'V4':\n        default:\n            return signTypedData_v4(privateKey, msgParams);\n    }\n}\nexports.signTypedMessage = signTypedMessage;\nfunction recoverTypedMessage(msgParams, version = 'V4') {\n    switch (version) {\n        case 'V1':\n            return recoverTypedSignatureLegacy(msgParams);\n        case 'V3':\n            return recoverTypedSignature(msgParams);\n        case 'V4':\n        default:\n            return recoverTypedSignature_v4(msgParams);\n    }\n}\nexports.recoverTypedMessage = recoverTypedMessage;\nfunction signTypedData(privateKey, msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data, false);\n    const sig = ethUtil.ecsign(message, privateKey);\n    return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));\n}\nexports.signTypedData = signTypedData;\nfunction signTypedData_v4(privateKey, msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data);\n    const sig = ethUtil.ecsign(message, privateKey);\n    return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));\n}\nexports.signTypedData_v4 = signTypedData_v4;\nfunction recoverTypedSignature(msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data, false);\n    const publicKey = recoverPublicKey(message, msgParams.sig);\n    const sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n}\nexports.recoverTypedSignature = recoverTypedSignature;\nfunction recoverTypedSignature_v4(msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data);\n    const publicKey = recoverPublicKey(message, msgParams.sig);\n    const sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n}\nexports.recoverTypedSignature_v4 = recoverTypedSignature_v4;\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHash(typedData) {\n    const error = new Error('Expect argument to be non-empty array');\n    if (typeof typedData !== 'object' ||\n        !('length' in typedData) ||\n        !typedData.length) {\n        throw error;\n    }\n    const data = typedData.map(function (e) {\n        return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value;\n    });\n    const types = typedData.map(function (e) {\n        return e.type;\n    });\n    const schema = typedData.map(function (e) {\n        if (!e.name) {\n            throw error;\n        }\n        return `${e.type} ${e.name}`;\n    });\n    return ethAbi.soliditySHA3(['bytes32', 'bytes32'], [\n        ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),\n        ethAbi.soliditySHA3(types, data),\n    ]);\n}\nfunction recoverPublicKey(hash, sig) {\n    const signature = ethUtil.toBuffer(sig);\n    const sigParams = ethUtil.fromRpcSig(signature);\n    return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);\n}\nfunction getPublicKeyFor(msgParams) {\n    const message = ethUtil.toBuffer(msgParams.data);\n    const msgHash = ethUtil.hashPersonalMessage(message);\n    return recoverPublicKey(msgHash, msgParams.sig);\n}\nfunction padWithZeroes(number, length) {\n    let myString = `${number}`;\n    while (myString.length < length) {\n        myString = `0${myString}`;\n    }\n    return myString;\n}\n// converts hex strings to the Uint8Array format used by nacl\nfunction nacl_decodeHex(msgHex) {\n    const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n    return naclUtil.decodeBase64(msgBase64);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}